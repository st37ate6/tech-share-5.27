# Corsa计划：用GO “移植” Typescript

## 关于前端编译与构建

我们写的 JavaScript（或 TypeScript）代码，**无法直接运行在浏览器中的生产环境中**，它必须经过「一系列工具处理」后，变成浏览器可以执行、运行效率更高的形式

```javascript
// src/main.ts
import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
```

这是 **TypeScript + 模块化语法（ESM）+ Vue SFC**，**浏览器不能直接理解完整的形式**

 使用构建工具进行处理（Vite、webpack、Rollup 等）

| 处理类型                  | 描述                                                |
| ------------------------- | --------------------------------------------------- |
| **模块打包**        | 把多个 `import/export` 模块合并成一个或多个文件   |
| **TypeScript 编译** | `.ts` → `.js`                                  |
| **Vue SFC 编译**    | `.vue` → 渲染函数 + JS 模块                      |
| **ES6 转换**        | 把 ES6+ 语法转换为浏览器广泛兼容的 JS（通过 Babel） |
| **压缩优化**        | 删除空格注释，改短变量名，Tree-Shaking 等           |
| **资源处理**        | 引用的图片、字体、CSS 文件路径优化与 hash 重写      |
| **HMR**（开发时）   | 模块热更新功能，支持快速更新组件而不刷新页面        |

## JavaScript的弊端

JavaScript 本身并不是为了计算密集型的系统级工作负载设计的

1. **JavaScript 是动态类型语言**，变量类型是运行时才决定的，**写错了不会报错**，直到运行崩溃
2. JavaScript 在浏览器中运行，性能全靠 JS 引擎（如 V8）做 JIT 优化。但：

   - 没有类型信息 → 很难做深层优化
   - 没有线程并发模型（无共享内存）
   - 执行模型基于事件循环和单线程
3. 浏览器限制堆大小：默认大概在 1GB~2GB

   - 没有精细内存控制（无法手动分配/释放）
   - 没有栈指针访问权限
4. JavaScript 本质上是为“网页交互”而设计，非为“系统级开发”准备：

   - 没有指针 / 原始内存访问能力
   - 无法高效处理线程、锁、通道等低层机制
   - **没有值类型结构体（struct by value）**，所有对象都是引用
5. 虽然有很多很好用的工具，但是你不能在结构体内联分发东西，并没有共享内存并发

## TypeScript 长期以来的性能问题

    TypeScript 编译器一直采用 自举（bootstrapping） 方式，意味着它是用 TypeScript 自己实现的。虽然这提供了一定的优势，但同时也带来了 性能瓶颈，尤其是在处理大型代码库时。

#### 主要性能瓶颈：

- **运行时环境开销**：TypeScript 编译器运行在 Node.js 环境中，每次启动都需要初始化 JavaScript 运行时，这带来了额外的开销。
- **动态对象模型**：JavaScript 允许灵活的数据结构，但这种特性在编译器这种高计算密集型任务中会拖慢速度。
- **内存管理**：无法像底层语言一样直接分配内存，导致数据结构的性能受限。
- **单线程执行**：无法利用多线程处理任务，导致编译速度受限。

#### 结果：

- 大型项目的加载和检查时间变长
- 经常发生内存溢出
- 开发者不得不在“编辑器启动速度”和“完整代码分析”之间做妥协

## 編譯機制與性能：

**代码形式与转换过程**

- **源代码（Source Code）**人类可读的高级编程语言代码

  * 例如：TypeScript、JavaScript、Go 等
- **中间代码（Intermediate Code）**

  * AST（抽象语法树）：源代码的树状结构表示
  * IR（中间表示）：与平台无关的中间形式
  * 字节码（Bytecode）：虚拟机可执行的指令集
- **目标代码（Target Code）**

  * 机器码：CPU 直接执行的二进制指令
  * 汇编代码：机器码的可读形式
  * 平台相关的原生代码

**编译优化层面**

- **前端优化（Front-end Optimization）**

  * 词法分析优化
  * 语法树优化
  * 类型检查优化
- **中端优化（Middle-end Optimization）**

  * 死代码消除
  * 常量折叠
  * 循环优化
  * 内联优化
- **后端优化（Back-end Optimization）**

  * 寄存器分配
  * 指令调度
  * 代码生成优化

**不同语言的编译路径**

- **TypeScript 路径**：

  * TypeScript → AST → JavaScript → V8 字节码 → 机器码
  * 多次转换带来性能开销
- **Go 路径**：

  * Go → AST → IR → 机器码
  * 直接生成原生代码，减少转换层级

**TypeScript 編譯過程**

- TypeScript 使用 AOT（Ahead-of-Time）編譯，而不是 JIT
- 編譯流程：源碼 → AST → 類型檢查 → JavaScript 代碼
- 編譯器本身用 TypeScript 編寫，運行在 Node.js 環境中

**AOT vs JIT 對比**

- AOT（預先編譯）

  * 編譯發生在執行前
  * 生成目標代碼一次性完成
  * 運行時性能穩定
  * 典型例子：TypeScript、C++、Go
- JIT（即時編譯）

  * 運行時動態編譯
  * 根據執行情況優化代碼
  * 性能可能波動
  * 典型例子：JavaScript V8 引擎

**編譯器性能開銷**

- **編譯器運行環境開銷**

  * Node.js 啟動時間
  * V8 引擎的 JIT 編譯
  * 
- **編譯過程開銷**

  * AST 構建和遍歷
  * 類型推導和檢查
  * 代碼生成和轉換
- **內存密集操作**

  * 符號表維護
  * 類型圖構建
  * 中間表示（IR）生成
