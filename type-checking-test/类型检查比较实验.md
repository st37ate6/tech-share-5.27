# 类型检查比较实验

这个文件夹包含了使用不同程序语言实现的类型检查示例，用于比较不同语言在处理类型安全方面的差异。

## 文件结构

```
type-checking-test/
├── README.md    # 本文件
├── sum.js       # JavaScript 实现（动态类型）
├── sum.ts       # TypeScript 实现（静态类型）
└── sum.go       # Go 实现（静态类型）
```

## 类型检查比较

### JavaScript (sum.js)

- 动态类型语言
- 运行时才会发现类型错误
- 允许隐式类型转换
- 更灵活但容易出错

**运行结果**：

```
12              // 1 + '2' = '12' —— 隐式类型转换，字符串拼接而不是数字相加
NaN             // 1 + undefined = NaN —— 缺少参数也不报错
true[object Object]  // true + {} —— 类型混乱，结果无意义
3               // 1 + 2 = 3 —— 只有正确的数字相加才符合预期
```

### TypeScript (sum.ts)

- 静态类型语言
- 编译时就能发现类型错误
- 提供类型推断和检查
- 增加了代码可维护性

**运行结果**：

```
error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
  sum(1, '2');     // 编译错误：不能将字符串赋值给数字类型
```

### Go (sum.go)

- 静态类型语言
- 强类型系统
- 编译时严格的类型检查
- 不允许隐式类型转换

**运行结果**：

```
=== Go 语言类型检查示例 ===
特点: 强类型系统，编译时严格检查，不允许隐式类型转换

1. 正确的类型使用:
[Go计算器] 整数相加: 10 + 20 = 30
[Go计算器] 浮点数相加: 3.14 + 2.86 = 6.00

2. 字符串转换 (需要显式处理):
[Go计算器] 字符串转换后相加: '15' + '25' = 40
转换成功，结果: 40
预期错误: 无法将 'abc' 转换为整数: strconv.Atoi: parsing "abc": invalid syntax

3. 泛型函数示例:
泛型整数相加: 300
泛型浮点数相加: 4.00
```

## 实验结果分析

1. **JavaScript**：

   - ✗ 允许任意类型混合运算
   - ✗ 隐式类型转换导致意外结果
   - ✗ 运行时才发现错误
   - ✓ 开发灵活，快速原型
2. **TypeScript**：

   - ✓ 编译时发现类型错误
   - ✓ 避免了运行时类型错误
   - ✓ 代码更可维护
   - ✓ 保持了 JavaScript 的灵活性
3. **Go**：

   - ✓ 最严格的类型检查
   - ✓ 强制显式类型转换
   - ✓ 支持泛型
   - ✓ 编译时保证类型安全
   - ✗ 相对不够灵活

## 结论

1. **JavaScript** 的动态类型系统提供了极大的灵活性，但也容易导致运行时错误。
2. **TypeScript** 通过静态类型检查在编译时就能发现潜在问题，提高了代码质量。
3. **Go** 的强类型系统提供了最严格的类型安全保证，虽然较不灵活，但能最大程度避免类型相关的错误。
